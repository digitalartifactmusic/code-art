#include <SFML/Graphics.hpp>

#include <iostream>
#include <vector>
#include <complex>

#include <thread>

static const unsigned USED_THREADS = 6;
static std::thread T1, T2, T3, T4, T5, T6, T7, T8;

const bool JULIA = true;
static std::complex<long double> JULIAPOINT = std::complex<long double>{ -0.8 , -0.156 }; // A Julia Set is a unique fractal generated by adding any one position on the complex plane to every point in the screenspace plane during their iteration instead of their own intitial position.
																				// This fractal has some very interesting properties and can actually be animated while iterating by translating or rotating the julia point within the complex plane.
static const unsigned MAX_ITERATIONS = 5000;

static const unsigned PIXEL_HEIGHT = 1000;
static const unsigned PIXEL_WIDTH = 2000;

static long double MAGNIFICATION = 0.99;
static const long double TARGET_X = (!(JULIA) * (long double)-0.7336438924199521) + ((JULIA) * (long double)0.0), TARGET_Y = (!(JULIA) * (long double)-0.2455211406714035) + ((JULIA) * (long double)0.0);

static const long double ROTATION = 50000.0;
static const long double TRANSLATE_REAL = -0.000001, TRANSLATE_IMAG = -0.000001;


static const long double RATIO = PIXEL_WIDTH / PIXEL_HEIGHT;

static long double PLANEDIV_HEIGHT = 2.0;
static long double PLANEDIV_WIDTH = PLANEDIV_HEIGHT * RATIO;
static long double ITERATE = 4.0 / PIXEL_HEIGHT;

static sf::Color COLORS[MAX_ITERATIONS];

static sf::RenderWindow WINDOW(sf::VideoMode{ PIXEL_WIDTH , PIXEL_HEIGHT }, "Mandelbrot");

static const unsigned SIZE = PIXEL_WIDTH * PIXEL_HEIGHT;
sf::VertexArray VERTEXARRAY(sf::Points, SIZE);

static sf::VertexArray* ANIMATE = new sf::VertexArray[SIZE];
static const sf::VertexArray* ANIMATE_BEGIN = ANIMATE;
static unsigned ANIMATE_SIZE;

void colorInit()
{
	sf::Uint8 r = 0, g = 0, b = 0;
	for (unsigned i = 0; i < MAX_ITERATIONS; i++)
	{
		r = 0, g = 0, b = 0;
		if ((i / 255) % 2)
		{
			r = 255 - (i % 256);
			b = 255;
		}
		else
		{
			r = i % 256;
			b = r;
		}

		COLORS[i] = sf::Color{ r, g, b };
	}
}

class Point
{
public:
	std::complex<long double> comp;
	unsigned pos;
	float x, y;

	Point() : comp{ 0.0, 0.0 }, pos{ 0 }, x{ 0.0f }, y{ 0.0f } {}

	Point(std::complex<long double> comp, unsigned pos, float x, float y) : comp{ comp }, pos{ pos }, x{ x }, y{ y } {}

};

static Point SCREENSPACE[SIZE];

void initialize()
{
	unsigned k = 0;
	long double y = -PLANEDIV_HEIGHT;
	for (float i = 0.0f; i < PIXEL_HEIGHT; i++)
	{
		long double x = -PLANEDIV_WIDTH;
		for (float j = 0.0f; j < PIXEL_WIDTH; j++)
		{
			SCREENSPACE[k] = Point{ std::complex<long double>{ x ,  y }, k, j, i };
			k++;
			x += ITERATE;
		}
		y += ITERATE;
	}
}

void iterate(const unsigned thread)
{
	unsigned i = thread, j;
	Point* point = SCREENSPACE + i;
	std::complex<long double> k;

	switch (JULIA)
	{
		case false:
		{
			while (i < SIZE)
			{
				k = { -PLANEDIV_WIDTH + (point->x * ITERATE) + TARGET_X,  -PLANEDIV_HEIGHT + (point->y * ITERATE) + TARGET_Y };
				point->comp = k;

				j = 0;
				while (1)
				{
					k = (k * k) + point->comp;									// If desired, k can be raised to a larger power here with the pow() function or by stringing it out manually. For every exponent there is a corresponding multibrot fractal. 
					j++;															// The Mandelbrot set is a multibrot fractal of power two.
					if (((k.real() * k.real()) + (k.imag() * k.imag())) > 3.9)
					{
						VERTEXARRAY[i] = { { point->x , point->y } , COLORS[j] };
						break;
					}

					if (j == MAX_ITERATIONS)
					{
						VERTEXARRAY[i].color = { 0 , 0 , 0 };
						break;
					}
				}

				point += USED_THREADS;
				i += USED_THREADS;
			}
			break;
		}
		case true:
		{
			while (i < SIZE)
			{
				k = { -PLANEDIV_WIDTH + (point->x * ITERATE) + TARGET_X,  -PLANEDIV_HEIGHT + (point->y * ITERATE) + TARGET_Y };

				j = 0;
				while (1)
				{
					k = (k * k) + JULIAPOINT;									// If desired, k can be raised to a larger power here with the pow() function or by stringing it out manually. For every exponent there is a corresponding multibrot fractal. 
					j++;															// The Mandelbrot set is a multibrot fractal of power two.
					if (((k.real() * k.real()) + (k.imag() * k.imag())) > 3.9)
					{
						VERTEXARRAY[i] = { { point->x , point->y } , COLORS[j] };
						break;
					}

					if (j == MAX_ITERATIONS)
					{
						VERTEXARRAY[i].color = { 0 , 0 , 0 };
						break;
					}
				}

				point += USED_THREADS;
				i += USED_THREADS;
			}
			break;
		}
	}
}

int main()
{
	colorInit();

	initialize();

	unsigned i = 0;
	while (WINDOW.isOpen())
	{
		sf::Event event;
		while (WINDOW.pollEvent(event))
		{
			if (event.type == sf::Event::Closed)
				WINDOW.close();
		}

		if (MAGNIFICATION < 1.0)
			MAGNIFICATION += 0.00003;

		ITERATE *= MAGNIFICATION;
		PLANEDIV_HEIGHT *= MAGNIFICATION;
		PLANEDIV_WIDTH *= MAGNIFICATION;

		T1 = std::thread(iterate, 0);			// My machine has 8 CPU threads available to me. I plan to install Cuda and make use of my GPU threads with proper thread pooling.
		T2 = std::thread(iterate, 1);
		T3 = std::thread(iterate, 2);
		T4 = std::thread(iterate, 3);
		T5 = std::thread(iterate, 4);
		T6 = std::thread(iterate, 5);
		//T7 = std::thread(iterate, 6);
		//T8 = std::thread(iterate, 7);

		T1.join();
		T2.join();
		T3.join();
		T4.join();
		T5.join();
		T6.join();
		//T7.join();
		//T8.join();

		WINDOW.draw(VERTEXARRAY);
		WINDOW.display();
		JULIAPOINT *= std::complex<long double>{ cos(3.1415926 / ROTATION), sin(3.1415926 / ROTATION) };
		JULIAPOINT += std::complex<long double>{ TRANSLATE_REAL , -TRANSLATE_IMAG };
	}

	return 0;
}
