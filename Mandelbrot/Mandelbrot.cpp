#include <SFML/Graphics.hpp>

#include <iostream>
#include <vector>
#include <complex>

#include <thread>

static const unsigned AVAILABLE_THREADS = 6;
//static std::vector<std::thread> THREADS(AVAILABLE_THREADS);

std::thread T1, T2, T3, T4, T5, T6, T7, T8;

static const bool JULIA = false;
static std::complex<long double> JULIAPOINT = std::complex<long double>{ -0.8 , -0.156 }; // A Julia Set is a unique fractal generated by adding any one position on the complex plane to every point in the screenspace plane during their iteration instead of their own intitial position.
																				// This fractal has some very interesting properties and can actually be animated while iterating by translating or rotating the julia point within the complex plane.
static const unsigned MAX_ITERATIONS = 2000;

static const unsigned PIXEL_HEIGHT = 1000;
static const unsigned PIXEL_WIDTH = 2000;

static long double MAGNIFICATION = 0.95;
static long double TARGET_X = (!(JULIA) * (long double)-0.7336438924199521) + ((JULIA) * (long double)0.0), TARGET_Y = (!(JULIA) * (long double)-0.2455211406714035) + ((JULIA) * (long double)0.0);

static long double ROTATE = 1000000.0;
static long double TRANSLATE = 0.0000001;

static const long double RATIO = PIXEL_WIDTH / PIXEL_HEIGHT;
static long double PLANE_HEIGHT = 2.0;
static long double PLANE_WIDTH = PLANE_HEIGHT * RATIO;
static long double PLANE_ITERATE = 4.0 / PIXEL_HEIGHT;

static sf::Color COLORS[MAX_ITERATIONS + 1];

static const unsigned SIZE = PIXEL_WIDTH * PIXEL_HEIGHT;

static sf::Vertex VERTEXARRAY[SIZE];

void colorInit()
{
	sf::Uint8 r = 0, g = 0, b = 0;

	COLORS[0] = { 0 , 0 , 0 };

	for (unsigned i = 1; i < MAX_ITERATIONS + 1; i++)
	{
		r = 0, g = 0, b = 0;
		if ((i / 255) % 2)
		{
			r = 255 - (i % 256);
			b = 255;
		}
		else
		{
			//for (unsigned j = 0; j < i; j++)
			//{
			//	r += 9;
			//	if (r > 255)
			//	{
			//		r = 0;
			//		b += 11;
			//		if (b > 255)
			//		{
			//			b = 0;
			//		}
			//	}
			//}
			r = (i % 256);
			b = r;
		}

		COLORS[i] = sf::Color{ r, g, b };
	}
}

class Point
{
public:
	std::complex<long double> comp;
	std::complex<long double> orig;
	float x, y;

	Point() : comp{ 0.0, 0.0 }, orig{ 0.0, 0.0 }, x{ 0.0f }, y{ 0.0f } {}

	Point(std::complex<long double> comp, std::complex<long double> orig, float x, float y) : comp{ comp }, orig{ orig }, x{ x }, y{ y } {}

	sf::Color* pointIterate()
	{
		unsigned i = 1;
		comp = { -PLANE_WIDTH + (x * PLANE_ITERATE) + TARGET_X,  -PLANE_HEIGHT + (y * PLANE_ITERATE) + TARGET_Y };
		orig = comp;

		while (1)
		{
			comp = (comp * comp) + orig;
			++i;

			if (((comp.real() * comp.real()) + (comp.imag() * comp.imag())) > 4)
				return COLORS + i;
			else if (i == MAX_ITERATIONS)
				return COLORS;
		}
	}
};

static std::vector<Point> SCREENSPACE(SIZE);

void initialize()
{
	unsigned k = 0;
	long double y = -PLANE_HEIGHT;
	for (float i = 0.0f; i < PIXEL_HEIGHT; i++)
	{
		long double x = -PLANE_WIDTH;
		for (float j = 0.0f; j < PIXEL_WIDTH; j++)
		{
			SCREENSPACE[k] = Point{ std::complex<long double>{ x ,  y }, std::complex<long double>{ x ,  y }, j, i };
			VERTEXARRAY[k].position = { j , i };
			k++;
			x += PLANE_ITERATE;
		}
		y += PLANE_ITERATE;
	}
}

void iterateMandelbrot(const unsigned thread)
{
	unsigned j;
	sf::Vertex* vertex = VERTEXARRAY + thread;
	std::complex<long double> temp, orig;

	for (std::vector<Point>::iterator point = SCREENSPACE.begin() + thread; point < SCREENSPACE.end(); point += AVAILABLE_THREADS)
	{
		temp = { -PLANE_WIDTH + (point->x * PLANE_ITERATE) + TARGET_X,  -PLANE_HEIGHT + (point->y * PLANE_ITERATE) + TARGET_Y };
		orig = temp;

		j = 0;
		while (1)
		{
			temp = (temp * temp) + orig;
			j++;
			if (((temp.real() * temp.real()) + (temp.imag() * temp.imag())) > 4.0)
			{
				vertex->color = COLORS[j];
				break;
			}

			if (j == MAX_ITERATIONS)
			{
				vertex->color = { 0 , 0 , 0 };
				break;
			}
		}

		vertex += AVAILABLE_THREADS;
	}
}

void iterateJulia(const unsigned thread)
{
	unsigned j;
	sf::Vertex* vertex = VERTEXARRAY + thread;
	std::complex<long double> temp;

	for(std::vector<Point>::iterator point = SCREENSPACE.begin() + thread; point < SCREENSPACE.end(); point += AVAILABLE_THREADS)
	{
		temp = { -PLANE_WIDTH + (point->x * PLANE_ITERATE) + TARGET_X,  -PLANE_HEIGHT + (point->y * PLANE_ITERATE) + TARGET_Y };

		j = 0;
		while (1)
		{
			temp = (temp * temp) + JULIAPOINT;
			j++;
			if (((temp.real() * temp.real()) + (temp.imag() * temp.imag())) > 4.0)
			{
				vertex->color = COLORS[j];
				break;
			}

			if (j == MAX_ITERATIONS)
			{
				vertex->color = { 0 , 0 , 0 };
				break;
			}
		}

		vertex += AVAILABLE_THREADS;
	}
}

int main()
{
	colorInit();

	initialize();

	sf::ContextSettings settings;
	//settings.antialiasingLevel = 2;

	static sf::RenderWindow window(sf::VideoMode{ PIXEL_WIDTH , PIXEL_HEIGHT }, "Mandelbrot", sf::Style::Default, settings);

	switch (JULIA)
	{
	case false:
	{
		unsigned i = 0, j;
		while (window.isOpen())
		{

			sf::Event event;
			while (window.pollEvent(event))
			{
				switch (event.type)
				{
				case sf::Event::Closed:
				{
					window.close();
					break;
				}
				case sf::Event::MouseWheelScrolled:
				{
					PLANE_ITERATE *= pow(MAGNIFICATION, event.mouseWheelScroll.delta);
					PLANE_HEIGHT *= pow(MAGNIFICATION, event.mouseWheelScroll.delta);
					PLANE_WIDTH *= pow(MAGNIFICATION, event.mouseWheelScroll.delta);
					break;
				}
				case sf::Event::MouseButtonPressed:
				{
					sf::Vector2i position = sf::Mouse::getPosition(window);
					std::complex<long double> k = { -PLANE_WIDTH + (position.x * PLANE_ITERATE) + TARGET_X,  -PLANE_HEIGHT + (position.y * PLANE_ITERATE) + TARGET_Y };
					TARGET_X = k.real();
					TARGET_Y = k.imag();
					break;
				}
				default:
					break;
				}
			}

			T1 = std::thread(iterateMandelbrot, 0);
			T2 = std::thread(iterateMandelbrot, 1);
			T3 = std::thread(iterateMandelbrot, 2);
			T4 = std::thread(iterateMandelbrot, 3);
			T5 = std::thread(iterateMandelbrot, 4);
			T6 = std::thread(iterateMandelbrot, 5);
			//T7 = std::thread(iterateMandelbrot, 6);
			//T8 = std::thread(iterateJulia, 7);

			T1.join();
			T2.join();
			T3.join();
			T4.join();
			T5.join();
			T6.join();
			//T7.join();
			//T8.join();

			window.draw(VERTEXARRAY, SIZE, sf::Points);
			window.display();
		}
		break;
	}
	case true:
	{
		unsigned i = 0, j;
		while (window.isOpen())
		{
			sf::Event event;

			while (window.pollEvent(event))
			{
				switch (event.type)
				{
				case sf::Event::Closed:
				{
					window.close();
					break;
				}
				case sf::Event::MouseWheelScrolled:
				{
					PLANE_ITERATE *= pow(MAGNIFICATION, event.mouseWheelScroll.delta);
					PLANE_HEIGHT *= pow(MAGNIFICATION, event.mouseWheelScroll.delta);
					PLANE_WIDTH *= pow(MAGNIFICATION, event.mouseWheelScroll.delta);
					break;
				}
				case sf::Event::MouseButtonPressed:
				{
					sf::Vector2i position = sf::Mouse::getPosition(window);
					std::complex<long double> k = { -PLANE_WIDTH + (position.x * PLANE_ITERATE) + TARGET_X, -PLANE_HEIGHT + (position.y * PLANE_ITERATE) + TARGET_Y };
					TARGET_X = k.real();
					TARGET_Y = k.imag();
					break;
				}
				case sf::Event::KeyPressed:
				{
					switch (event.key.code)
					{
					case sf::Keyboard::R:
					{
						JULIAPOINT *= { cos(3.1415926 / ROTATE), sin(3.1415926 / ROTATE) };
						break;
					}
					case sf::Keyboard::F:
					{
						JULIAPOINT /= { cos(3.1415926 / ROTATE), sin(3.1415926 / ROTATE) };
						break;
					}
					case sf::Keyboard::W:
					{
						JULIAPOINT += { TRANSLATE, 0.0 };
						break;
					}
					case sf::Keyboard::S:
					{
						JULIAPOINT += { -TRANSLATE, 0.0 };
						break;
					}
					case sf::Keyboard::A:
					{
						JULIAPOINT += { 0.0, -TRANSLATE };
						break;
					}
					case sf::Keyboard::D:
					{
						JULIAPOINT += { 0.0, TRANSLATE };
						break;
					}
					case sf::Keyboard::Q:
					{
						TRANSLATE /= 10;
						break;
					}
					case sf::Keyboard::E:
					{
						TRANSLATE *= 10;
						break;
					}
					case sf::Keyboard::Z:
					{
						ROTATE /= 10;
						break;
					}
					case sf::Keyboard::C:
					{
						ROTATE *= 10;
						break;
					}
					default:
						break;
					}
					break;
				}
				default:
					break;
				}
			}

			T1 = std::thread(iterateJulia, 0);
			T2 = std::thread(iterateJulia, 1);
			T3 = std::thread(iterateJulia, 2);
			T4 = std::thread(iterateJulia, 3);
			T5 = std::thread(iterateJulia, 4);
			T6 = std::thread(iterateJulia, 5);
			T7 = std::thread(iterateJulia, 6);
			//T8 = std::thread(iterateJulia, 7);

			T1.join();
			T2.join();
			T3.join();
			T4.join();
			T5.join();
			T6.join();
			T7.join();
			//T8.join();

			window.draw(VERTEXARRAY, SIZE, sf::Points);
			window.display();
		}
		break;
	}
	}

	return 0;
}
